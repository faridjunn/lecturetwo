# Область видимости (Scope).
Область видимости (Scope) - это текущий контекст выполнения, в котором значения и выражения являются "видимыми" или на которые можно ссылаться; это объединённое множество идентификаторов, доступ к которым имеет текущий контекст.
До ES6 (2015) у JavaScript были только Global Scope и Function Scope .

ES6 представил два важных новых ключевых слова JavaScript: letи const.

Эти два ключевых слова обеспечивают область действия блока в JavaScript.

К переменным, объявленным внутри блока { }, нельзя получить доступ снаружи блока:

Если переменная или другое выражение не находится "в текущей области видимости", то оно недоступно для использования.

###### Что есть глобальная/локальная ОВ?
Не написав ни строчки кода, мы уже находимся в глобальной ОВ. Если мы сразу определяем переменную, она находится в глобальной ОВ.
- // глобальная ОВ
var name = 'Todd';

Глобальная ОВ – ваш лучший друг и худший кошмар. Обучаясь работе с разными ОВ, вы не встретите проблем с глобальной ОВ, разве что вы увидите пересечения имён. Часто можно услышать «глобальная ОВ – это плохо», но нечасто можно получить объяснение – почему. ГОВ – не плохо, вам нужно её использовать при создании модулей и API, которые будут доступны из разных ОВ, просто нужно использовать её на пользу и аккуратно.

Все мы использовали jQuery. Как только мы пишем
- jQuery('.myClass');

мы получаем доступ к jQuery в глобальной ОВ, и мы можем назвать этот доступ пространством имён. Иногда термин «пространство имён» используют вместо термина ОВ, однако обычно им обозначают ОВ самого уровня. В нашем случае jQuery находится в глобальной ОВ, и является нашим пространством имён. Пространство имён jQuery определено в глобальной ОВ, которая работает как ПИ для библиотеки jQuery, в то время как всё её содержимое наследуется от этого ПИ.

###### Что такое локальная ОВ?

Локальной ОВ называют любую ОВ, определённую после глобальной. Обычно у нас есть одна ГОВ, и каждая определяемая функция несёт в себе локальную ОВ. Каждая функция, определённая внутри другой функции, имеет своё локальное ОВ, связанное с ОВ внешней функции.

Если я определю функции и задам внутри переменные, они принадлежат локальной ОВ. 
Пример:
- // ОВ A: глобальная
var myFunction = function () {
  // ОВ B: локальная
};

Все переменные из ЛОВ не видны в ГОВ. К ним нельзя получить доступ снаружи напрямую. Пример:
- var myFunction = function () {
  var name = 'Todd';
  console.log(name); // Todd
};
// ReferenceError: name is not defined
console.log(name);

Переменная “name” относится к локальной ОВ, она не видна снаружи и поэтому не определена.

Все локальные ОВ создаются только в функциональных ОВ, они не создаются циклами типа for или while или директивами типа if или switch. Новая функция – новая область видимости.
Пример:
- // ОВ A
var myFunction = function () {
  // ОВ B
  var myOtherFunction = function () {
    // ОВ C
  };
};

Так просто можно создать новую ОВ и локальные переменные, функции и объекты.
######  Лексическая ОВ
Если одна функция определена внутри другой, внутренняя имеет доступ к ОВ внешней. Это называется «лексической ОВ», или «замыканием», или ещё «статической ОВ».
- var myFunction = function () {
  var name = 'Todd';
  var myOtherFunction = function () {
    console.log('My name is ' + name);
  };
  console.log(name);
  myOtherFunction(); // вызов функции
};
// Выводит:
// `Todd`
// `My name is Todd`

С лексической ОВ довольно просто работать – всё, что определено в ОВ родителя, доступно в ОВ ребенка. 
К примеру:
- var name = 'Todd';
var scope1 = function () {
  // name доступно здесь
  var scope2 = function () {
    // name и здесь
    var scope3 = function () {
      // name и даже здесь!
    };
  };
};

В обратную сторону это не работает:
- // name = undefined
var scope1 = function () {
  // name = undefined
  var scope2 = function () {
    // name = undefined
    var scope3 = function () {
      var name = 'Todd'; // локальная ОВ
    };
  };
};

Всегда можно вернуть ссылку на “name”, но не саму переменную.
###### Последовательности ОВ
Последовательности ОВ определяют ОВ любой выбранной функции. У каждой определяемой функции есть своя ОВ, и каждая функция, определяемая внутри другой, имеет свой ОВ, связанный с ОВ внешней – это и есть последовательность, или цепочка. Позиция в коде определяет ОВ. Определяя значение переменной, JS идёт от самой глубоко вложенной ОВ наружу, пока не найдёт искомую функцию, объект или переменную.

## Подъем JavaScript
Подъем — это поведение JavaScript по умолчанию для перемещения объявлений наверх.
###### Объявления JavaScript поднимаются
В JavaScript переменная может быть объявлена ​​после ее использования.

Другими словами; переменная может использоваться до того, как она была объявлена.
Пример 1:
- x = 5; // Assign 5 to x
elem = document.getElementById("demo"); // Find an element
elem.innerHTML = x;                     // Display x in the element
var x; // Declare x

Пример 2:
- var x; // Declare x
x = 5; // Assign 5 to x
elem = document.getElementById("demo"); // Find an element
elem.innerHTML = x;                     // Display x in the element

Чтобы понять это, вы должны понять термин «подъем».

Поднятие — это поведение JavaScript по умолчанию, когда все объявления перемещаются в верхнюю часть текущей области (в верхнюю часть текущего скрипта или текущей функции).

###### Ключевые слова let и const
Переменные, определенные с помощью letи, constподнимаются наверх блока, но не инициализируются .

Значение: Блок кода знает о переменной, но ее нельзя использовать, пока она не будет объявлена.

Использование letпеременной до ее объявления приведет к созданию файла ReferenceError.

Переменная находится во «временной мертвой зоне» с начала блока до ее объявления:
Пример:
- carName = "Volvo";
let carName;   // Это приведет к ReferenceError:

Использование constпеременной до ее объявления является синтаксической ошибкой, поэтому код просто не запустится.
Пример:
- carName = "Volvo";
const carName;    // Этот код не будет работать.

# Три типа переменных
Вначале в JavaScript был только один тип переменных. Когда вы хотели объявить новую переменную, вы должны были использовать varключевое слово. Это изменилось, когда была выпущена спецификация ECMAScript 6 . Одним изменением, которое было введено этой спецификацией, были два новых типа переменных.

Эти новые два типа переменных были let и const . Есть различия между ними, var, letи const. Некоторые из этих различий более важны, некоторые менее. Среди этих различий есть два, которые важны для понимания того, как работает временная мертвая зона в JavaScript. Также как это работает с каждым типом.

- // Declare variable with var keyword
var myVariableVar = 'Lex'

- // Declare variable with let keyword
let myVariableLet = 47

- // Declare variable with const keyword
const myVariableConst = ['DC']

###### Три типа прицелов
Первое важное отличие заключается в том, как эти переменные работают с областью действия. В JavaScript есть два, ну, три типа области видимости: глобальная, локальная или функциональная и блочная. Глобальная область — это область вне какой-либо функции или блока кода. Локальная или функциональная область — это область внутри функций. Когда вы создаете функцию, вы также создаете локальную область.

Переменные, объявленные в глобальной области видимости, видны и доступны везде. Переменные, которые вы объявляете в локальной области, доступны и видны только внутри этой области, а не за ее пределами. Третья область, блок, создается с помощью пары фигурных скобок. Например, когда вы используете оператор [if...else], какой-то цикл и т. д., вы также создаете область действия блока.
- // Variable in a global scope
let myGlobalVariable = 'Global'

- // Variable in a local (function) scope
function myFunc() {
  // This is new local scope
  // created for this function
  let myLocalVariable = 'Local'
}

- // Variable in a block scope
if (true) {
  // New block scope is created inside the curly brackets
  let myBlockVariable = 'Block'
}

###### Область действия и переменная
Важной особенностью varпеременной является то, что она заботится только о первых двух: глобальной и локальной области видимости. Его не волнует третье: область действия блока. Допустим, вы объявили переменную, используя varглобальную область видимости. Затем вы создали область блока с if...elseоператором. Внутри него вы объявили другую varпеременную.

Эта новая переменная имеет то же имя, что и глобальная переменная var. Поскольку varне заботится о области блока, varвнутри if...elseбудет перезаписан глобальный файл var.
- // Declare variable with var
var myVariableVar = 'Lex'
// Create block scope with if...else statement
if (true) {
  // Declare new variable with var,
  // but use the same name as for the first var
  var myVariableVar = 'Alexander'
}
// Log the value of myVariableVar
console.log(myVariableVar)
// Output:
// 'Alexander'

###### Область видимости и пусть (и const)
Вышеуказанное не произойдет, если вы объявите эти переменные с помощью let. Переменная letзнает и уважает область действия блока. Используя if...elseоператор, вы создаете новую область блока. Эта область ограничивает видимость и доступность новой letпеременной. JavaScript «видит» эти две letпеременные как две разные.

- // Declare variable with let
let myVariableLet = 'Lex'
// Create block scope with if...else statement
if (true) {
  // Declare new variable with let,
  // but use the same name as for the first let
  let myVariableLet = 'Alexander'
}
// Log the value of myVariableLet
console.log(myVariableLet)
// Output:
// 'Lex'

Переменная constработает так же, как и let. Он также учитывает область действия блока. Таким образом, block-scoped constне будет конфликтовать с global constили наоборот.
- // Declare variable with const
const myVariableConst = 'Lex'
// Create block scope with if...else statement
if (true) {
  // Declare new variable with const,
  // but use the same name as for the first const
  const myVariableConst = 'Alexander'
}
// Log the value of myVariableConst
console.log(myVariableConst)
// Output:
// 'Lex'

##### Различия в объявлении и инициализации между var, let и const
Что вам нужно знать, так это то, что этот процесс немного отличается для некоторых типов переменных. Первый шаг такой же. Что отличается, так это второй шаг. Когда вы объявляете переменную varбез инициализации, она все равно будет инициализирована. Переменные, которые вы объявляете, varбудут иметь значение по умолчанию undefined.

Это undefinedтакже то, что вы получите, если попытаетесь получить доступ к значению объявленной, но не инициализированной varпеременной. Переменные, которые вы объявляете letи constработают по-разному. У них нет значения по умолчанию. Вы также не можете получить к ним доступ до их инициализации, до того, как вы присвоите им какое-то значение.

Ну, это больше верно для , letчем const. Когда вы используете, constвы должны объявить его и инициализировать. Требуется некоторое значение . Одна интересная вещь заключается в varтом, что вы можете повторно объявить его столько раз, сколько захотите. Если вы повторно объявите его в той же области, более новый перезапишет старый.

Это не работает с let, и это также не работает с const. Попробуйте повторно объявить letили constв той же области видимости, и JavaScript выдаст SyntaxError. Будет сказано, что какой-то идентификатор уже объявлен.
- // Declare variable with var
// This will work flawlessly
var myVariableVar = 'first'
var myVariableVar = 'second'
console.log(myVariableVar)
// Output:
// 'second'


- // Declare variable with let
let myVariableLet = 'first'
let myVariableLet = 'second'
// SyntaxError: Identifier 'myVariableLet' has already been declared


- // Declare variable with const
const myVariableConst = 'first'
const myVariableConst = 'second'
// SyntaxError: Identifier 'myVariableConst' has already been declared

# Рекурсия
Одним из основных препятствий, с которыми я столкнулся при понимании рекурсии, было то, что у нее нет доступных API/специальных языковых конструкций/встроенных функций.

В случае итерации у нас есть циклы всех видов, но в случае рекурсии нам не предоставляются какие-либо встроенные решения. Мы должны реализовать его с нуля.

Это может блокировать обучение, но, в конечном счете, именно это делает рекурсию полезной, поскольку дает нам полный контроль над тем, когда, почему и как выполняется повторение.

Давайте посмотрим несколько примеров! Во-первых, давайте console.logчисла от 0 до 10, точно так же, как мы делали выше с forциклом, но на этот раз рекурсивно:
- const printNumbersUpTo10 = (num = 0) => { // #1 for (let i = 0;
  if (num <= 10) { // #2 i <= 10;
    console.log(num); // ⬅️ procedure to repeat
    printNumbersUpTo10(num + 1); // #3 i++)
  }
};
printNumbersUpTo10();

Там могут быть некоторые удивительные детали (мы вернемся к ним позже), но давайте сначала сосредоточимся на сходстве между рекурсивным и итеративным подходами.
Сходства с итерацией
Я сопоставил строки рекурсивной printNumbersUpTo10функции с эквивалентными частями forцикла, давайте рассмотрим их шаг за шагом:

В строке #1мы объявляем переменную, которую мы будем увеличивать при каждомитерацияшаг. Таким образом, эта строка эквивалентна:
- for (
  let i = 0; // ⬅️
  i <= 10;
  i++
) { console.log(i); }

В строке #2задаем условие, которое будет проверять на каждомитерацияшаг, независимо от того, сделали ли мы уже или есть еще шаги, которые нужно выполнить. В рекурсивных функциях это условие имеет специальное название, оно называется "базовый случай". Таким образом, эта строка эквивалентна:
- for (
  let i = 0;
  i <= 10; // ⬅️
  i++
) { console.log(i); }

В строке #3мы увеличиваем нашу переменную счетчика. Таким образом, эта строка эквивалентна:
- for (
  let i = 0;
  i <= 10;
  i++ // ⬅️
) { console.log(i); }

Несмотря на то, что рекурсия и итерация имеют много общего, они различаются в нескольких важных аспектах. Чтобы понять эти различия, давайте подробно обсудим, как работает рекурсия.

# Как работает рекурсия?
С точки зрения любого движка JavaScript рекурсия — это просто ситуация, когда функция вызывает сама себя.

Чтобы понять, что это значит, давайте реорганизуем нашу printNumbersUpTo10функцию из предыдущего примера. Допустим, мы решили, что printNumbersUpTo10это слишком специфично, поэтому нам нужна более общая printNumbersUpToфункция, которая будет принимать 1 аргумент — наибольшее число, которое она должна вывести.

Итак, когда мы будем звонить, printNumbersUpTo(5)это должны быть console.logцифры от 0 до 5.

Наша первая попытка реализовать это может выглядеть примерно так:
- const printNumbersUpTo = (num) => {
  if (num >= 0) {
    console.log(num);
    printNumbersUpTo(num - 1); // ⬅️ this line makes it tick
  }
};
printNumbersUpTo(5); // ➡️ logs 5, 4, 3, 2, 1, 0

Однако здесь у нас есть пара проблем:

1. Числа печатаются от 5 до 0 вместо 0 до 5.
2. Мы должны сделать дополнительный ненужный шаг только для того, чтобы напечатать 0, потому что наш console.logоператор расположен рядом с printNumbersUpToвызовом, который вызывает printNumbersUpToсам себя еще один раз, когда numравен 0 (-1 не регистрируется, потому что он не проходит проверку внутри ifоператора).

Попробуем избавиться от обеих проблем. Лучшее решение может быть примерно таким:
- const printNumbersUpTo = (num) => {
  if (num > 0) {
    printNumbersUpTo(num - 1);
  }
 console.log(num);
};
printNumbersUpTo(5); // ➡️ logs 0, 1, 2, 3, 4, 5

Вы заметили, как перемещение console.logниже printNumbersUpTo(num - 1)вызова изменило последовательность регистрации с 5 ➡️ 0 на 0 ➡️ 5?

Это работало таким образом, потому что, когда JS-компилятор добирается до printNumbersUpTo(num - 1)него, он сразу же начинает его выполнять, затем printNumbersUpTo(num - 1)снова видит и начинает его выполнять, и так далее.

В результате компилятор сначала проходит весь путь до вызова, где numfinally равно 0. Когда равен num0, условие внутри оператора ifложно, поэтому ifоператор пропускается и console.logвыполняется.

После ничего нет console.log, поэтому компилятор завершает работу с самой внутренней функцией, а затем начинает возвращаться к самой внешней области.

# Замыкания JavaScript
Переменные JavaScript могут принадлежать локальной или глобальной области видимости.

Глобальные переменные можно сделать локальными (приватными) с помощью замыканий .
###### Глобальные переменные
A functionможет получить доступ ко всем переменным, определенным внутри функции, например:
- function myFunction() {
  let a = 4;
  return a * a;
}

Но a functionтакже может обращаться к переменным, определенным вне функции, например:
- let a = 4;
function myFunction() {
  return a * a;
}

В последнем примере a — это глобальная переменная.

На веб-странице глобальные переменные принадлежат странице.

Глобальные переменные могут использоваться (и изменяться) всеми другими скриптами на странице.

В первом примере a — локальная переменная.

Локальная переменная может использоваться только внутри функции, в которой она определена. Он скрыт от других функций и другого кода сценариев.

Глобальные и локальные переменные с одинаковыми именами являются разными переменными. Изменение одного не меняет другого.
###### Примечание
Переменные, созданные без ключевого слова объявления ( var, let, или const), всегда являются глобальными, даже если они созданы внутри функции.
Пример:
- function myFunction() {
  a = 4;
}
